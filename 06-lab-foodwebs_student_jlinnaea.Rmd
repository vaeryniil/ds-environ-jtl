---
output:
  pdf_document: default
  html_document: default
---
##  Lab: Food Webs & Network Measures (Student Version)

```{r lab_setup, include=FALSE}
knitr::opts_chunk$set(error = TRUE, warning = TRUE, message = TRUE)
suppressPackageStartupMessages({
  if (requireNamespace("tidyverse", quietly = TRUE)) library(tidyverse)
  if (requireNamespace("igraph", quietly = TRUE)) library(igraph)
  if (requireNamespace("bipartite", quietly = TRUE)) library(bipartite)
  if (requireNamespace("networks3D", quietly = TRUE)) library(bipartite)
})
net_data <- function(...) file.path("labs", "data", ...)
```

### Lesson Overview

**Computational Topics**
- Build and visualize food webs 
- Write functions to implement mathematical equations

**Conservation topics**
-  Paleofood webs
-  Species extinction

In this lab we will practice our network visualization and manipulation skills using the paleo food web data from [Yeakel et al. 2014](https://doi.org/10.1073/pnas.1408471111). 

![Paleoweb](labs/figures/paleoweb.jpg)

See the beautiful, animated version of the graphic above [here](https://infograficos.estadao.com.br/public/cidades/extincoes-egito/)

With some interaction networks we can observe the interactions, for example plant-pollinator networks, seed-disperal networks, human social networks. In food webs sometimes feeding interactions are observed directly, through camera traps, people doing timed observations, and now molecular analysis of gut contents/scat. However, often with food webs people build probabilistic models of who interacts with who based on body size (as in the Yeakel et al. 2014), especially with paleowebs. Thus the data from Yeakel et al. is 1) an occurrence matrix  (Figure 2 from the publication) and a matrix of body sizes (two columns, females then males). We will use these data to build the foodwebs for each time period. This lab is pretty challenging because it will use many of our core programming skills (for loops, writing functions, subsetting data) and our network skills. 

First we will read in the data. The matrix we are reading in has no row or column names, we will have to set them. 

```{r}
sp_occ <- read.table(file="data/egypt_data.txt", header = FALSE)
str(sp_occ)
sp_mass <- read.table(file="data/egypt_mass.txt", header=FALSE)
str(sp_mass)
```
![Figure 2](labs/figures/figure2.jpg)

The rows are arranged in the order of Figure 2 of the manuscript. To set the rownames we can make a vector of the names then use the function `rownames`. We also have to note which species are predators (all those in the species in the Carnivora clade in figure 2). Otherwise we will create a web where giraffes are voracious predators consuming all of the other species (I made this mistake when constructing the networks originally). I have transcribed the data from figure 2 for you: 
 
```{r}
row_labs_sp <- c("Canis aureus", "Vulpes vulpes", "Lycaon pictus", "Hyaena hyaena", "Crocuta crocuta", "Panthera leo (long maned)", "Panthera leo (short maned)", "Panthera pardus", "Acinonyx jubatus", "Loxodonta africana", "Equus asinus", "Equus grevyi", "Equus quagga", "Diceros/Ceratotherium", "Sus scrofa",  "Phacochoerus aethiopicus", "Hippopotamus amphibius", "Giraffa camelopardalis", "Dama mesopotamica", "Camelus dromedarius", "Taurotragus oryx", "Tragelaphus spekei", "Addax nasomaculatus", "Oryx dammah", "Oryx beisa", "Hippotragus equinus", "Kobus kob", "Kobus megaceros", "Alcelaphus bucelaphus", "Connochaetes taurinus", "Litocranius walleri", "Ammodorcas clarkei", "Gazella dorcas", "Gazella leptoceros", "Gazella soemmerringii", "Capra ibex", "Ammotragus lervia", "Bos primigenius", "Syncerus caffer")

###  Set 1 for predators, 0 for prey  
carnivores <- c(rep(1, 9), rep(0, length(row_labs_sp)- 9))
names(carnivores) <- row_labs_sp
```

```{r}
#my test cell
#row_labs_sp
carnivores
```

###  Lab question 1: Creating our foodwebs based on body sizes.

- 1a. Use the above vector of species names to label the row names of the species occurrence and the body size matrices.  The columns of the species occurrence matrix are time points, so we can leave those as V1 etc., but we should set the column names of the mass matrix as "f", "m" (female and male). Use `head` to check each matrix to see if the names are displayed properly. 

```{r}
#add the row names vector as row labels in each of the two data frames
rownames(sp_occ) <- row_labs_sp
rownames(sp_mass) <- row_labs_sp

#add f and m as column names to sp_mass
colnames(sp_mass) <- c('f','m')

#examine the data frames
head(sp_occ)
head(sp_mass)
dim(sp_occ)
```
Yeakel recommended an updated equation to estimate the probability a predator consumed a prey based on their relative body masses from [Rohr et al. 2010.](https://doi.org/10.1086/653667). The  probability of existence of a trophic link between a predator of body-size $m_i$ and a prey of body-size $m_j$ is given by:

![Probabilitic feeding equation](labs/figures/feeding_equ.png)
(P($A_{1j}$ = 1) is the probability predator i eats prey j). 

- 1b. Write a function and call it `probEat` to implement the equation above. Round the probability to two decimal places.

Below are the values of alpha, beta, and gamma for the Serengeti.  In addition, you will need a function to compute the inverse logit function because this equation is for the logit of the probability, so to calculate the 0-1 probability you will need to take the inverse logit of the other side of the equation. Also note, $log^2$ is equivalent to (log($m_i$/$m_j$))^2

```{r}
alpha <- 2.51
beta <- 0.79
gamma <- -0.37
  
inv_logit <- function(x) exp(x)/(1+exp(x))
inv_logit
```

```{r}
#a function to calculate the probabalistic feeding equation
#alpha, beta, and gamma are constants
#mj and mi are the body masses of the two species
probEat <- function(alpha,beta,gamma,mj,mi){
  logit <- alpha + (beta * log(mj/mi)) + (gamma * (log(mj/mi))^2)
  return (inv_logit(logit))
}
```

- 1c. Now create networks of who eats whom. We will start with adjacency matrices. We will assume all of our species are the size of females. For this step, don`t worry about predators vs. prey yet, just calculate all of the feeding probabilities based on body sizes.  

Hint: if you start with a square matrix of all zeros (one row and one column for each species), you can use a for loop to fill in that matrix with probabilities calculated from your function above.

```{r}
# calculate how many species are present in the data (from sp_mass)
num_sp = nrow(sp_mass)
#print(num_sp) #scaffolding

#set an empty matrix with dimensions(# of species by # of species)
species_matrix = matrix(0,num_sp,num_sp)

#fill the matrix with the predation probabilities of each species with 
#every other by using the probEat() function defined above
for (i in 1:num_sp) {
  for (j in 1:num_sp) {
    species_matrix[i,j] <- round(probEat(alpha,beta,gamma, sp_mass[i,'f'],sp_mass[j,'f']),2)
  }
}
#give the new matrix row and column labels (of species names)
rownames(species_matrix) <- row_labs_sp
colnames(species_matrix) <- row_labs_sp
species_matrix
```

```{r}
#test cell
sum(species_matrix[,'Canis aureus'] > 0)

```
- 1d. Now that you have your matrix of potential feeding interactions based on body size, use the `carnivores` vector created above to set all of the feeding interactions of herbivores (0s in that vector) to zero. In foodwebs the columns are the higher trophic level and the rows are the lower.
HINT: the function `sweep` may be useful, though there are many approaches to do the needed matrix multiplication. Print the row and column sums. 

```{r}
# use sweep to set any column with a prey animal(value 0 in the carnivores vecter) to zero
#MARGIN=2 means perform the sweep column-wise (1 is row-wise)
#We do this column-wise because the columns represent the upper trophic level and the 
#rows represent the lower trophic level (a predator in column can eat a prey in row,
#but a prey in column cannot eat a predator in row)
pred_prey_mat <- sweep(species_matrix,MARGIN=2,carnivores, `*`)
pred_prey_mat
```

### Lab question 2: Breaking the networks into time periods

- 2a. With our matrix of feeding interaction we can create a web for each time period, including only the species that were not extinct in the period. Try first just using the second time period (the second column of `sp_occ`). 

Use the function `empty` from the bipartite package to empty the matrix of rows and columns with no interactions. The number of species in the second time period is 36 `sum(sp_occ[,2])`. Check to see that the number of rows in your network with probabilities > 0 is 36. 

HINT: You will need to zero out the rows where a species in not present in that time period and the columns. The function `sweep` may be useful again.

```{r}
#isolating just the values in the V2 column
v2_sp <- sp_occ[,'V2']
print(v2_sp) #scaffolding

#using sweep() to zero any species row where that species isn't present (is 0 in V2_sp)
v2_matrix <- sweep(pred_prey_mat, MARGIN=1, v2_sp, `*`)

#using sweep() to zero any species col. where that species isn't present
v2_matrix <- sweep(v2_matrix, MARGIN=,2, v2_sp, `*`)

#A test for using the empty() function. Not used, see Note below
#sum(v2_matrix[,'Canis aureus'] > 0)


#Note! Using the graphing function below doesn't work unless the matrices are square.
#Therefore, I'm not going to use the empty() function.
#using empty() to remove any column or row that's entirely zeroes (that species isn't present in the V2 column)
#v2_matrix <- bipartite::empty(v2_matrix,count=TRUE)
sum(v2_matrix[,'Canis aureus'] > 0)
```

```{r}
#additional test cell:
#era_test_vector <- sp_occ[,'V2'] #how i did it before
#era_itest_vector <- sp_occ[,2] #an equally valid way, and the way to use in loop
#era_test_vector
#era_itest_vector

#all_eras_network_list = vector(mode="list", length=3)
#all_eras_network_list[[1]] = c(1,2)
#all_eras_network_list
```


- 2b. Now create a network for all of the time points by creating a list where each element is a network. You will need to use a for loop, or an `lapply` if you feel like experimenting with apply functions. Print the first 5 columns and rows of the 5th time period. 

HINT: If choosing the for loop route, remember to create an empty list of a specific length use the function `vector`. To access a specific element of a list, use [[]], for example cool_list[[1]] accesses the first element of the list.

```{r}
###  your code here

#To make a list where each element is a network representing one time period of the sp_occ
#DataFrame, I'll loop a number of times equal to the columns (time periods), and for each time period implement the steps from the question above. 
#As in the previous question, I'll use the matrix made in 1.d. as my starting point.

#start by making an empty list
all_eras_network_list = vector(mode="list", length=length(sp_occ)) #this is good! prof approves

#start a loop
for (i in 1: ncol(sp_occ)) {
  
  #make a vector of species present in that era (1 = present, 0 = not present)
  era_species <- sp_occ[,i]
  
  #using sweep() to zero any species row where that species isn't present in the era
  era_matrix <- sweep(pred_prey_mat, MARGIN=1, era_species, `*`)
  
  #using sweep() to zero any species col where that species isn't present in the era
  era_matrix <- sweep(era_matrix, MARGIN=,2, era_species, `*`)
  
  #era_matrix <- bipartite::empty(era_matrix,count=TRUE) #this still messes it up
  
  #appending the era_matrix to the list
  all_eras_network_list[[i]] = era_matrix
}

length(all_eras_network_list)
all_eras_network_list[[5]][1:5,1:5]
#all_eras_network_list[[23]][16:20,1:5]
```

###  Lab question 3: Visualize the networks
- 3a. Convert the adjacency matrices to igraph class objects using the function `graph_from_adjacency_matrix`. You can use a for loop or an lapply. Because these are food webs, set the argument mode to "directed" and the argument diag to FALSE (this means a species cannot consumer members of its own species, i.e., no canabalism/self-loops). Also remember that these interactions are weighted.  

```{r}

many_igraph_objects <- vector(mode="list", length=length(sp_occ))

for (i in 1: ncol(sp_occ)) {

network_object <- graph_from_adjacency_matrix(
  all_eras_network_list[[i]],
  mode = "directed",
  weighted = TRUE,
  diag = FALSE,
)

many_igraph_objects[[i]] = network_object
}
```


```{r}
#test cell. created after submission
class(many_igraph_objects[[2]])
```

- 3b. Plot three networks of your choice, using different colors for the predators and prey.

```{r}
#the GE says:
#From earlier in the lab we created a named vector (carnivores) that lists whether each species is a carnivore or herbivore. We also have the list of networks from the previous question. You can use bracket indexing of carnivores to subset the species nodes in a particular network in the network list to return a vector that has "carnivore" or "herbivore" in the same order as the nodes in the network, which can then be provided to the igraph_to_networkD3 groups argument.

###  assign groups as carnivore or herbivore
#V(network_object)$group <- carnivores[V(network_object)$name] #I'm doing this
#manually with code an LLM suggested. It seems to work, but I still can't 
#get the graphs to look right, so I'm not sure.
V(many_igraph_objects[[2]])$group <- carnivores[V(many_igraph_objects[[2]])$name] 

###  convert to a network 3d object
networkD3 <- igraph_to_networkD3(many_igraph_objects[[2]],group = V(many_igraph_objects[[2]])$group)

# ###  plot the network
forceNetwork(Links = networkD3$links,
             Nodes = networkD3$nodes,
            Source = "source", Target = "target",
            Value = "value",  NodeID = "name",
             Group = "group",
            opacity = 0.8, zoom=TRUE, opacityNoHover = 0.9)

# sankeyNetwork(Links = networkD3$links,
#              Nodes = networkD3$nodes,
#             Source = "source", Target = "target",
#             Value = "value",  NodeID = "name",
#             nodePadding = 0, height = 5000)

```

```{r}
# your code here
V(many_igraph_objects[[9]])$group <- carnivores[V(many_igraph_objects[[9]])$name] 

###  convert to a network 3d object
networkD3 <- igraph_to_networkD3(many_igraph_objects[[9]],group = V(many_igraph_objects[[9]])$group)

# ###  plot the network
forceNetwork(Links = networkD3$links,
             Nodes = networkD3$nodes,
            Source = "source", Target = "target",
            Value = "value",  NodeID = "name",
             Group = "group",
            opacity = 0.8, zoom=TRUE, opacityNoHover = 0.9)
```

```{r}
V(many_igraph_objects[[23]])$group <- carnivores[V(many_igraph_objects[[23]])$name] 

###  convert to a network 3d object
networkD3 <- igraph_to_networkD3(many_igraph_objects[[23]],group = V(many_igraph_objects[[23]])$group)

# ###  plot the network
forceNetwork(Links = networkD3$links,
             Nodes = networkD3$nodes,
            Source = "source", Target = "target",
            Value = "value",  NodeID = "name",
             Group = "group",
            opacity = 0.8, zoom=TRUE, opacityNoHover = 0.9)
```
